#####最佳置换算法（Optimal：OPT）
+ 算法实质是预测作业今后要访问的页面，置换页是将来不被访问的页面或者在最长时间后才被访问的页面，置换该页不会造成刚置换出去又被立即调入的现象。
+ 采用该算法可以保证获得最低的却也中断率，是一种理想化的置换算法，性能最好。
+ 它要求操作系统知道进程”将来“页面使用情况，但这是不可能实现的，因为程序运行是不可预测的。
#####最进先出置换算法（First Input First Out：FIFO）
+ 该算法总是淘汰最先进入内存的页面，即选择在内存中驻留的时间最久的页面予以淘汰。
+ 该算法与实际运行的规律不符，因为在进程中有些页面经常被访问，如含有全局变量，常用函数，FIFO不能保证这些页面不被淘汰。
+ 该算法没有考虑到动态变化情况，对于某一特定页面走向，算法会出现却也中断率随着被分配的内存快增加反而上升的反常现象（**belady现象**或**抖动现象**）。
#####最近最久未使用置换算法（Least Recently Used：LRU）
+ 页面调入的先后不能反应页面的使用情况
+ LRU是根据页面调入内存后的使用情况来确定页面的调出
#####clock置换算法
+ LRU算法比FIFO好，但需要硬件支持，算法操作复杂且实现代价高，因此在实现上往往采用近似LRU算法。
+ clock算法是一种近似LRU算法
######简单的clock置换算法
+ 利用页表中设立的一位访问位即可实现，当某页被访问时访问位置1，否则清零。系统周期性对所有访问位清0.
+ 当需要置换一页时，从那些访问位为0的页中选一页进行置换
+ 算法易于实现 ，开销小。
######改进型clock置换算法
+ 在将一个页面换出时，如果该页已被修改过，便需将它重新写到磁盘上，但如果该页未被修改，则不必将它写会外存
+ 由访问位A和修改位M可以组合成下面四种类型的页面：
1. A=0，M=0：表示该页最近未被使用，也未被修改，是首选被淘汰的页
2. A=0，M=1：表示该页最近未被访问，但已修改，是其次被淘汰的页
3. A=1，M=0：最近已访问，但未被修改，是再次选择被淘汰的页
4. A=1，M=1：最近被访问且被修改，是最后选择被淘汰的页面
#####最少使用置换算法（Least Frequently Used：LFU）
+ 实质是选择置换到当前时刻为止访问次数最少的一页
+ 优点是实现不难，每一页设置一个计数器，每访问一次计数器加1，缺页中断时选计数器值最小的页面先置换，每隔时间间隔T对计数器清0.缺点是代价较高，且合适的间隔T的选择也是一个难题。



#####关于缺页中断率
######影响缺页中断率的因素
1. 页面本身的大小
2. 分配给进程的物理页数
3. 程序的编制方法
4. 页面置换算法

