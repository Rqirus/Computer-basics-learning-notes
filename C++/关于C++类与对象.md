#### new 与 直接声明对象的区别
+ C++直接声明类的对象，对象的内存空间分配在栈区，对象的内存空间随着栈内存的释放而释放
+ new声明的存储空间需要用指针来接收，需要手动用delete来释放，如若没有释放则内存泄漏。 
####关于对象的深拷贝与浅拷贝
+ 浅拷贝是默认的对象拷贝方式，在没有写拷贝构造函数前。拷贝只是简单的字段赋值。
+ 深拷贝指当拷贝的对象有对其他资源的引用时，拷贝的对象另开辟新的空间与资源，而不是单纯的赋值，然后同步拷贝开辟空间的值。

需要注意的是：拷贝构造函数中的参数不能是值传递，如果是值传递，实参复制到形参时仍需调用拷贝构造函数，造成无限递归。所以编译器禁止这样的行为.

#### 关于拷贝构造函数与赋值运算符重载
+ 拷贝构造函数，顾名思义：在需要构造一个不存在的对象时调用。
+ 赋值则是对已存在的对象进行赋值。

调用拷贝构造函数的时机
+ 使用一个已经存在的对象对另一个对象初始化。
+ 在函数中形参以值传递
+ 以值返回参数列表中的对象时，会复制构造一个临时对象

#### 关于对象生存期
静态变量放在程序的全局数据区，而不是在堆栈中分配

#### 关于类的继承与类中访问
（1）基类的私有成员无论什么继承方式，在派生类中均不可以直接访问
（2）在公有继承下，基类的保护成员和公有成员均保持原访问属性
（3）在保护继承方式下，基类的保护和公有成员在派生类的访问属性均为保护属性
（4）在私有继承下，基类的保护和公有成员在派生类中的访问属性均为私有属性


#### 关于类成员变量的初始化列表
构造函数中变量的初始化顺序是按其定义的顺序，与初始化列表中的顺序无关。

#### 关于基类本类及子对象构造函数调用的先后顺序
1.如果有基类，先调用基类构造函数。
2.如果有子对象，先调用子类对象构造函数。
3.调用自身构造函数。

#### 关于类的析构函数与拷贝构造函数
类中含有指针，且没有写拷贝构造函数时需要注意。
进行浅拷贝构造时只是简单的将指针赋值，而没有申请新的空间。
如果析构函数中有释放指针的语句。如果有调用拷贝构造函数可能导致，同一指针释放多次。

#### 关于类的静态数据成员
+ 非常量静态的数据成员在类中定义，在类的实现文件中初始化
+ 常量静态数据成员在类中定义并初始化

#### 关于类的虚函数
+ 在基类中声明了为虚函数的函数，即便在派生类中没有声明为virtual，仍然视作虚函数。


#### 关于常对象
+ 常对象只能调用只读函数const函数
+ 对象在生存期间不能修改

#### 关于友元函数
+ 定义在类中的友元函数也是正确的。

